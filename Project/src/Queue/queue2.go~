package Queue

import (
	"fmt"
	"os"
	"os/exec"
	"driver"
)


const (
	UP = 0
	DOWN = 1
)

type node struct{
	value order
	next *node
}

type linkedList struct{
	head *node
	last *node
	length int
}

//var allQueues map[int]linkedList

var queue = linkedList{nil,nil,0}
var qList [] int
/*
func init(){
	//var queue = linkedList{nil,nil,0} 
	//fetchMyQueue()
	//allQueues[elevatorID] = queue
}*/


func Queue(addOrderChannel chan driver.ButtonMessage, removeOrderChannel chan int, setDirectionChannel chan int, checkDirectionChannel chan int, checkOrdersChannel chan int, stop chan int){//, findBestElevator chan driver.ButtonMessage ){
	turn := false
	direction := 0
	currentFloor := 0
	//queueInit()
	
	for{
	/*println("\t\t\t\tORDERS DOWN ", ordersInDirection[DOWN] ,"\n\n\n")
	println("\t\t\t\tORDERS UP", ordersInDirection[UP] ,"\n\n\n")
	println("\t\t\t\tTURN", turn ,"\n\n\n")*/
		select{
			case newOrder := <- addOrderChannel:
				
				go addOrder(1, newOrder, currentFloor, direction)

			case <- removeOrderChannel: 
				println("QUEUE: REMOVEORDER DIRECTION:")
				removeOrder(1, currentFloor, direction, &turn)
				
				
			case movingDirection := <- checkDirectionChannel:
				direction = movingDirection
				println("QUEUE: CHECKDIRECTION DIRECTION:", direction)
				/*if(checkIfOrdersInDirection(1, currentFloor, direction, &turn) != -1){
					setDirectionChannel <- direction
					break
				} else{*/
					newDirection := setDirection(1, currentFloor, &turn)
					direction = newDirection
					setDirectionChannel <- newDirection
					break
				//}

			case floor := <- checkOrdersChannel:
				println("QUEUE: CHECKORDER DIRECTION:", direction)
				currentFloor = floor
				if(checkOrders(1, currentFloor, direction, &turn)){
					if(turn){
						stop <- int(math.Abs(float64(1-direction)))
					}else{
						stop <- direction
					}
					break
				} 
				
			//case <- findBestElevatorChannel:

		}
	}
}



func addOrder(elevatorID int, orderz  driver.ButtonMessage, currentFloor int, movingDirection int) {
	var newOrder = order{orderz.Floor, orderz.Button}
	var noden = node{newOrder, nil}
	
	if (queue.length == 0) {
		queue.head = &noden
		queue.last = &noden
		queue.length = 1
	} else if (queue.length == 1) {
		if equalOrders(queue.head.value, newOrder) {
			return
		} else {
			queue.length = 2
			if equalOrders(compareOrders(queue.head.value, newOrder, currentFloor, movingDirection), newOrder) {
				noden.next = queue.last
				queue.head = &noden
			} else {
				queue.head.next = &noden
				queue.last = &noden
			}
		}
	} else {
		var nodePointer = &node{queue.head.value, queue.head.next}
		if equalOrders(nodePointer.value, newOrder) {
			return
		} else if equalOrders(compareOrders(nodePointer.value, newOrder, currentFloor, movingDirection), newOrder) {
			noden.next = nodePointer
			queue.head = &noden
			queue.length++
			return
		}
		for i:=0; i < queue.length-1; i++ {
			 if equalOrders(nodePointer.next.value, newOrder) {
			 	return
			 } else {
			 	if equalOrders(compareOrders(nodePointer.next.value, newOrder, currentFloor, movingDirection), newOrder) {
					noden.next = nodePointer.next
					nodePointer.next = &noden
					queue.length++
					return
				} else {
					nodePointer = nodePointer.next
				}
			 }
		}
		queue.last.next = &noden
		queue.last = &noden
		queue.length++
	}
}

func compareOrders(oldOrder order, newOrder order, currentFloor int, direction int) order {
	if newOrder.Button== driver.BUTTON_COMMAND {
		if newOrder.floor < currentFloor {
			//direction DOWN
			if oldOrder.floor >  newOrder.floor {
				return oldOrder
			} else if oldOrder.floor < newOrder.floor {
				return newOrder
			} 
		} else if newOrder.floor > currentFloor {
			//direction UP
			if oldOrder.floor <  newOrder.floor {
				return oldOrder
			} else if oldOrder.floor > newOrder.floor {
				return newOrder
			} else if newOrder.floor == currentFloor {
				return oldOrder
			}	
		}
	} else if newOrder.Button== driver.BUTTON_CALL_DOWN {
		if direction == UP {
			if (oldOrder.Button== driver.BUTTON_CALL_DOWN && oldOrder.floor < newOrder.floor){
				return newOrder
			} else if (oldOrder.Button!= driver.BUTTON_CALL_DOWN && oldOrder.floor < currentFloor) {
				return newOrder
			} else {
				return oldOrder
			}
		} else if direction == DOWN {
			if (oldOrder.Button> newOrder.button) {
				return oldOrder
			} else {
				return newOrder
			}
		}
	} else if newOrder.Button== driver.BUTTON_CALL_UP {
		if direction == DOWN {
			if (oldOrder.Button== driver.BUTTON_CALL_UP && oldOrder.floor > newOrder.floor) {
				return newOrder
			}  else if (oldOrder.Button!= driver.BUTTON_CALL_UP && oldOrder.floor > currentFloor) {
				return newOrder
			} else {
				return oldOrder
			}
		} else if direction == UP {
			if (oldOrder.Button< newOrder.button) {
				return oldOrder
			} else {
				return newOrder
			}
		}
	}
	return oldOrder
}

func equalOrders(oldOrder order, newOrder order) bool {
	return (oldOrder.floor == newOrder.floor && oldOrder.Button== newOrder.button)
}

func removeOrder() {
	nodePointer := queue.head
	
	for {
		if (nodePointer.value.floor == nodePointer.next.value.floor) {
			nodePointer = queue.head.next
			queue.head = nodePointer
			queue.length--
		} else {
			nodePointer = queue.head.next
			queue.head = nodePointer
			queue.length--
			break
		}
	}
}

func clearAllOrders(){
	queue.head = nil
	queue.last = nil
	queue.length = 0
}

func printQueue() {
	println("Element 1:\nEtasje: ", queue.head.value.floor, "\tKnapp: ", queue.head.value.button,"\n")
	var noden *node
	noden = queue.head.next
	for i:=1 ; i < queue.length; i++ {
		println("Element", i+1,":\nEtasje: ", noden.value.floor, "\tKnapp: ", noden.value.button,"\n")
		noden = noden.next
	}
}
/*
func fetchMyQueue() {
	q := FileHandler.Read(&NumOfElevs, &NumOfFloors)
	
	//queue.length = q[0], NEI!!
	clearAllOrders()
		
	for j:=0; j < len(q); j+=2 {
		ord := driver.ButtonMessage{q[j],q[j+1]}
		addOrder(elevatorID , ord, currentFloor , movingDirection)
	}
}
*/
/*
func recieveExternalQueue() {
	// newQ := noko---
	// its direction
	// its currFloor
	// its ID
	// "Lag" ny kø
	// allQueues[ID] = nyKø 
	// kun ha ordre i allQueues?
}
*/
/*
func findBestElevator() int {
	best = 1
	min := findElevatorCost(1, newOrder)
	
	for elev := 2; elev <= NumOfElevs; elev++ {
		itsCost := findElevatorCost(elev, newOrder)
		
		if min > itsCost {
			best = elev
		}
	} 
	return best
}
*/
/*
func findElevatorCost(elevatorID int, newOrder driver.ButtonMessage) int {
	//for my ID:
	//		find which position in queue will new order get
	// Omtrent lik addOrder, bare returnerer pos, uten å legge til i kø
	return position
}
*/
 /*
func saveAndSendQueue() {
	
	qList = append([]int(nil), queue.head.value.floor)
	qList = append(qList, queue.head.value.button)
	
	var noden *node
	noden = queue.head.next
	for i:=1 ; i < queue.length; i++ {
		qList = append(qList, noden.value.floor)
		qList = append(qList, noden.value.button)
		noden = noden.next
	}
	
	FileHandler.Write(NumElevs, NumOfFloors, qList)
	//UDP.sendQueue()
	
}
*/
